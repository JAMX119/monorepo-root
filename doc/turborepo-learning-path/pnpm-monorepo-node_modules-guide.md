# pnpm Monorepo 中 node_modules 安装机制详解

## 问题分析

关于 `c:\Users\Admin\Desktop\work\monorepo-root` 中不同项目执行 `pnpm install` 时node_modules安装位置不同的现象，需要重新分析。通过进一步检查目录结构，发现根目录实际上并没有node_modules目录，这是理解当前状况的关键。

## 真实情况解析

经过详细检查，发现以下重要事实：

1. **根目录缺少node_modules**：
   monorepo根目录目前没有node_modules目录，这表明根目录从未执行过`pnpm install`命令。

2. **workspace配置存在但未激活**：
   虽然根目录的`package.json`中定义了workspaces，`pnpm-workspace.yaml`中也设置了`nodeLinker: hoisted`，但这些配置只有在根目录执行`pnpm install`后才会生效。

3. **子项目独立安装行为**：
   当在各个子项目（如admin-react、web-nextjs、react-native-expo）中单独执行`pnpm install`时，由于根目录没有共享的node_modules，pnpm会在每个子项目目录中创建独立的node_modules。

## pnpm monorepo的正确工作流程

pnpm的`hoisted`模式在monorepo中的正确工作流程应该是：

1. **在根目录初始化**：在monorepo根目录执行`pnpm install`，这会：
   - 创建根目录的node_modules
   - 安装所有workspace中项目共享的依赖
   - 根据`nodeLinker: hoisted`配置，将依赖统一提升并共享

2. **子项目依赖解析**：完成根目录安装后，子项目会自动引用根目录的node_modules，而不是在自己目录创建。

## 当前项目情况说明

根据目录检查结果，当前项目处于以下状态：

1. 根目录有monorepo配置文件（package.json、pnpm-workspace.yaml、turbo.json）
2. 根目录从未执行过`pnpm install`，因此没有node_modules
3. 各子项目单独执行过`pnpm install`，所以在各自目录创建了node_modules

## 最佳实践建议

为了正确利用monorepo的优势，建议按照以下步骤操作：

1. **在根目录执行统一安装**：
   ```bash
   cd c:\Users\Admin\Desktop\work\monorepo-root
   pnpm install
   ```
   这将创建根目录的node_modules并实现依赖共享。

2. **添加新依赖的正确方式**：
   - 为特定项目添加依赖：`pnpm add <package> --filter <project-name>`
   - 为所有项目添加共享依赖：`pnpm add <package> -w`

3. **清理子项目的node_modules**：
   在根目录安装完成后，可以删除各子项目的node_modules，因为它们会自动引用根目录的依赖：
   ```bash
   rm -rf apps/*/node_modules
   ```

4. **使用turbo管理任务**：
   利用根目录的turbo配置统一管理各项目的构建、开发等任务：
   ```bash
   pnpm run dev  # 并行运行所有项目的开发服务器
   pnpm run build  # 构建所有项目
   ```

## 常见问题排查

1. **为什么有些项目执行`pnpm install`后node_modules在子项目？**
   - 原因：根目录未执行过`pnpm install`，没有共享的node_modules
   - 解决方案：在根目录执行`pnpm install`以激活monorepo功能

2. **如何确保依赖版本一致性？**
   - 使用根目录package.json中的`pnpm.overrides`字段统一管理关键依赖版本
   - 避免在子项目中指定不同版本的共享依赖

## 总结

当前项目中，由于根目录从未执行过`pnpm install`，即使配置了`nodeLinker: hoisted`，各子项目在执行`pnpm install`时仍会在自己目录创建node_modules。要正确利用monorepo的优势，应在根目录执行`pnpm install`，实现依赖共享和统一管理。这样可以提高空间效率、确保版本一致性，并充分发挥turbo的构建优化能力。